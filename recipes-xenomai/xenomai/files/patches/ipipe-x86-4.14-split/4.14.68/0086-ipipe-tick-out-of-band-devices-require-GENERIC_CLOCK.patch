From 7ed14aa5ab512e4090567b85b6cd481866f5da86 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 22 Aug 2018 16:01:19 +0200
Subject: [PATCH 086/137] ipipe: tick: out-of-band devices require
 GENERIC_CLOCKEVENTS

Drop the legacy support for architectures not enabling the generic
clock event framework, which would only provide periodic timing.

We don't support any of those archs, and there is no point in running
a Xenomai co-kernel on a hardware not capable of handling oneshot
timing requests.
---
 kernel/ipipe/Kconfig |  1 +
 kernel/ipipe/timer.c | 19 -------------------
 2 files changed, 1 insertion(+), 19 deletions(-)

diff --git a/kernel/ipipe/Kconfig b/kernel/ipipe/Kconfig
index 03a37b5..6ff02a1 100644
--- a/kernel/ipipe/Kconfig
+++ b/kernel/ipipe/Kconfig
@@ -1,5 +1,6 @@
 
 config HAVE_IPIPE_SUPPORT
+       depends on GENERIC_CLOCKEVENTS
        bool
       
 config IPIPE
diff --git a/kernel/ipipe/timer.c b/kernel/ipipe/timer.c
index 0da9564..85b083c 100644
--- a/kernel/ipipe/timer.c
+++ b/kernel/ipipe/timer.c
@@ -36,7 +36,6 @@
 
 static DEFINE_PER_CPU(struct ipipe_timer *, percpu_timer);
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 /*
  * Default request method: switch to oneshot mode if supported.
  */
@@ -141,7 +140,6 @@ void ipipe_host_timer_register(struct clock_event_device *evtdev)
 
 	ipipe_timer_register(timer);
 }
-#endif /* CONFIG_GENERIC_CLOCKEVENTS */
 
 /*
  * register a timer: maintain them in a list sorted by rating
@@ -180,13 +178,7 @@ static void ipipe_timer_request_sync(void)
 		return;
 
 	evtdev = timer->host_timer;
-
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 	steal = evtdev != NULL && !clockevent_state_detached(evtdev);
-#else /* !CONFIG_GENERIC_CLOCKEVENTS */
-	steal = 1;
-#endif /* !CONFIG_GENERIC_CLOCKEVENTS */
-
 	timer->request(timer, steal);
 }
 
@@ -231,11 +223,9 @@ static void select_root_only_timer(unsigned cpu, unsigned hrclock_khz,
 	 */
 	for_each_cpu(icpu, mask) {
 		if (t->irq == per_cpu(ipipe_percpu.hrtimer_irq, icpu)) {
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 			evtdev = t->host_timer;
 			if (evtdev && clockevent_state_shutdown(evtdev))
 				continue;
-#endif /* CONFIG_GENERIC_CLOCKEVENTS */
 			goto found;
 		}
 	}
@@ -280,11 +270,9 @@ int ipipe_select_timers(const struct cpumask *mask)
 			if (!cpumask_test_cpu(cpu, t->cpumask))
 				continue;
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 			evtdev = t->host_timer;
 			if (evtdev && clockevent_state_shutdown(evtdev))
 				continue;
-#endif /* CONFIG_GENERIC_CLOCKEVENTS */
 			goto found;
 		}
 
@@ -421,7 +409,6 @@ int ipipe_timer_start(void (*tick_handler)(void),
 		return ret;
 	}
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 	steal = evtdev != NULL && !clockevent_state_detached(evtdev);
 	if (steal && evtdev->ipipe_stolen == 0) {
 		timer->real_mult = evtdev->mult;
@@ -444,10 +431,6 @@ int ipipe_timer_start(void (*tick_handler)(void),
 	}
 
 	ret = get_dev_mode(evtdev);
-#else /* CONFIG_GENERIC_CLOCKEVENTS */
-	steal = 1;
-	ret = 0;
-#endif /* CONFIG_GENERIC_CLOCKEVENTS */
 
 	ipipe_critical_exit(flags);
 
@@ -472,7 +455,6 @@ void ipipe_timer_stop(unsigned cpu)
 	if (desc && irqd_irq_disabled(&desc->irq_data))
 		ipipe_disable_irq(timer->irq);
 
-#ifdef CONFIG_GENERIC_CLOCKEVENTS
 	if (evtdev) {
 		flags = ipipe_critical_enter(NULL);
 
@@ -489,7 +471,6 @@ void ipipe_timer_stop(unsigned cpu)
 
 		ipipe_critical_exit(flags);
 	}
-#endif /* CONFIG_GENERIC_CLOCKEVENTS */
 
 	ipipe_free_irq(ipipe_head_domain, timer->irq);
 }
-- 
1.9.1

