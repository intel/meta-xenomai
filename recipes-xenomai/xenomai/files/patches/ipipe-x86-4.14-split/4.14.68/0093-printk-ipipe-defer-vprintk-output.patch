From 5a97b2843916810b4525b59deffb3a6e4a927d22 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Sun, 9 Sep 2018 18:30:55 +0200
Subject: [PATCH 093/137] printk: ipipe: defer vprintk() output

---
 kernel/printk/printk.c | 136 ++++++++++++++++++++++++-------------------------
 1 file changed, 67 insertions(+), 69 deletions(-)

diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 72f68e3..3f4c912 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -1771,44 +1771,6 @@ asmlinkage int vprintk_emit(int facility, int level,
 }
 EXPORT_SYMBOL(vprintk_emit);
 
-asmlinkage int vprintk(const char *fmt, va_list args)
-{
-	return vprintk_func(fmt, args);
-}
-EXPORT_SYMBOL(vprintk);
-
-asmlinkage int printk_emit(int facility, int level,
-			   const char *dict, size_t dictlen,
-			   const char *fmt, ...)
-{
-	va_list args;
-	int r;
-
-	va_start(args, fmt);
-	r = vprintk_emit(facility, level, dict, dictlen, fmt, args);
-	va_end(args);
-
-	return r;
-}
-EXPORT_SYMBOL(printk_emit);
-
-int vprintk_default(const char *fmt, va_list args)
-{
-	int r;
-
-#ifdef CONFIG_KGDB_KDB
-	/* Allow to pass printk() to kdb but avoid a recursion. */
-	if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {
-		r = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
-		return r;
-	}
-#endif
-	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
-
-	return r;
-}
-EXPORT_SYMBOL_GPL(vprintk_default);
-
 #ifdef CONFIG_IPIPE
 
 extern int __ipipe_printk_bypass;
@@ -1868,37 +1830,12 @@ void __ipipe_flush_printk (unsigned virq, void *cookie)
 	raw_spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
 }
 
-/**
- * printk - print a kernel message
- * @fmt: format string
- *
- * This is printk(). It can be called from any context. We want it to work.
- *
- * We try to grab the console_lock. If we succeed, it's easy - we log the
- * output and call the console drivers.  If we fail to get the semaphore, we
- * place the output into the log buffer and return. The current holder of
- * the console_sem will notice the new output in console_unlock(); and will
- * send it to the consoles before releasing the lock.
- *
- * One effect of this deferred printing is that code which calls printk() and
- * then changes console_loglevel may break. This is because console_loglevel
- * is inspected when the actual printing occurs.
- *
- * See also:
- * printf(3)
- *
- * See the vsnprintf() documentation for format string extensions over C99.
- */
-
-asmlinkage __visible int printk(const char *fmt, ...)
+static int do_vprintk(const char *fmt, va_list args)
 {
 	int sprintk = 1, cs = -1;
 	unsigned long flags;
-	va_list args;
 	int ret;
 
-	va_start(args, fmt);
-
 	flags = hard_local_irq_save();
 
 	if (__ipipe_printk_bypass || oops_in_progress)
@@ -1920,27 +1857,88 @@ asmlinkage __visible int printk(const char *fmt, ...)
 	} else
 		ret = __ipipe_log_printk(fmt, args);
 
-	va_end(args);
-
 	return ret;
 }
 
 #else /* !CONFIG_IPIPE */
 
-asmlinkage __visible int printk(const char *fmt, ...)
+static int do_vprintk(const char *fmt, va_list args)
+{
+	return vprintk_func(fmt, args);
+}
+
+#endif /* !CONFIG_IPIPE */
+
+asmlinkage int vprintk(const char *fmt, va_list args)
+{
+	return do_vprintk(fmt, args);
+}
+EXPORT_SYMBOL(vprintk);
+
+asmlinkage int printk_emit(int facility, int level,
+			   const char *dict, size_t dictlen,
+			   const char *fmt, ...)
 {
 	va_list args;
 	int r;
 
 	va_start(args, fmt);
-	r = vprintk_func(fmt, args);
+	r = vprintk_emit(facility, level, dict, dictlen, fmt, args);
 	va_end(args);
 
 	return r;
 }
+EXPORT_SYMBOL(printk_emit);
+
+int vprintk_default(const char *fmt, va_list args)
+{
+	int r;
+
+#ifdef CONFIG_KGDB_KDB
+	/* Allow to pass printk() to kdb but avoid a recursion. */
+	if (unlikely(kdb_trap_printk && kdb_printf_cpu < 0)) {
+		r = vkdb_printf(KDB_MSGSRC_PRINTK, fmt, args);
+		return r;
+	}
+#endif
+	r = vprintk_emit(0, LOGLEVEL_DEFAULT, NULL, 0, fmt, args);
+
+	return r;
+}
+EXPORT_SYMBOL_GPL(vprintk_default);
+
+/**
+ * printk - print a kernel message
+ * @fmt: format string
+ *
+ * This is printk(). It can be called from any context. We want it to work.
+ *
+ * We try to grab the console_lock. If we succeed, it's easy - we log the
+ * output and call the console drivers.  If we fail to get the semaphore, we
+ * place the output into the log buffer and return. The current holder of
+ * the console_sem will notice the new output in console_unlock(); and will
+ * send it to the consoles before releasing the lock.
+ *
+ * One effect of this deferred printing is that code which calls printk() and
+ * then changes console_loglevel may break. This is because console_loglevel
+ * is inspected when the actual printing occurs.
+ *
+ * See also:
+ * printf(3)
+ *
+ * See the vsnprintf() documentation for format string extensions over C99.
+ */
+asmlinkage __visible int printk(const char *fmt, ...)
+{
+	va_list args;
+	int r;
 
-#endif /* CONFIG_IPIPE */
+	va_start(args, fmt);
+	r = do_vprintk(fmt, args);
+	va_end(args);
 
+	return r;
+}
 EXPORT_SYMBOL(printk);
 
 #else /* CONFIG_PRINTK */
-- 
1.9.1

