From bbdb123b730b72f8b6ee6bedb5d2cfdee6696fc0 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 4 Jul 2018 18:32:51 +0200
Subject: [PATCH 013/137] printk: ipipe: defer printk() from head domain

The printk() machinery cannot immediately invoke the console driver(s)
when called from the head domain, since such driver code belongs to
the root domain and cannot be shared between domains.

Output issued from the head domain is formatted then logged into a
staging buffer, and a dedicated virtual IRQ is posted to the root
domain for notification. When the virtual IRQ handler runs, the
contents of the staging buffer is flushed to the printk() interface
anew, which may eventually pass the output on to the console drivers
from such a context.
---
 kernel/ipipe/core.c    |  16 ++++++++
 kernel/printk/printk.c | 101 +++++++++++++++++++++++++++++++++++++++++++++++++
 2 files changed, 117 insertions(+)

diff --git a/kernel/ipipe/core.c b/kernel/ipipe/core.c
index eba6ebf..070c049 100644
--- a/kernel/ipipe/core.c
+++ b/kernel/ipipe/core.c
@@ -102,6 +102,11 @@
 
 static unsigned long __ipipe_virtual_irq_map;
 
+#ifdef CONFIG_PRINTK
+unsigned int __ipipe_printk_virq;
+int __ipipe_printk_bypass;
+#endif /* CONFIG_PRINTK */
+
 #ifdef CONFIG_PROC_FS
 
 struct proc_dir_entry *ipipe_proc_root;
@@ -306,6 +311,14 @@ void __init __ipipe_init_early(void)
 	__ipipe_early_core_setup();
 	__ipipe_early_client_setup();
 
+#ifdef CONFIG_PRINTK
+	__ipipe_printk_virq = ipipe_alloc_virq();
+	ipd->irqs[__ipipe_printk_virq].handler = __ipipe_flush_printk;
+	ipd->irqs[__ipipe_printk_virq].cookie = NULL;
+	ipd->irqs[__ipipe_printk_virq].ackfn = NULL;
+	ipd->irqs[__ipipe_printk_virq].control = IPIPE_HANDLE_MASK;
+#endif /* CONFIG_PRINTK */
+
 	__ipipe_work_virq = ipipe_alloc_virq();
 	ipd->irqs[__ipipe_work_virq].handler = __ipipe_do_work;
 	ipd->irqs[__ipipe_work_virq].cookie = NULL;
@@ -1478,6 +1491,9 @@ void __ipipe_spin_unlock_debug(unsigned long flags)
 
 void ipipe_prepare_panic(void)
 {
+#ifdef CONFIG_PRINTK
+	__ipipe_printk_bypass = 1;
+#endif
 	ipipe_context_check_off();
 }
 EXPORT_SYMBOL_GPL(ipipe_prepare_panic);
diff --git a/kernel/printk/printk.c b/kernel/printk/printk.c
index 0fb2d8b..ac3b7fb 100644
--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -38,6 +38,7 @@
 #include <linux/kmsg_dump.h>
 #include <linux/syslog.h>
 #include <linux/cpu.h>
+#include <linux/ipipe.h>
 #include <linux/notifier.h>
 #include <linux/rculist.h>
 #include <linux/poll.h>
@@ -1808,6 +1809,65 @@ int vprintk_default(const char *fmt, va_list args)
 }
 EXPORT_SYMBOL_GPL(vprintk_default);
 
+#ifdef CONFIG_IPIPE
+
+extern int __ipipe_printk_bypass;
+
+static IPIPE_DEFINE_SPINLOCK(__ipipe_printk_lock);
+
+static int __ipipe_printk_fill;
+
+static char __ipipe_printk_buf[__LOG_BUF_LEN];
+
+int __ipipe_log_printk(const char *fmt, va_list args)
+{
+	int ret = 0, fbytes, oldcount;
+	unsigned long flags;
+
+	raw_spin_lock_irqsave(&__ipipe_printk_lock, flags);
+
+	oldcount = __ipipe_printk_fill;
+	fbytes = __LOG_BUF_LEN - oldcount;
+	if (fbytes > 1)	{
+		ret = vscnprintf(__ipipe_printk_buf + __ipipe_printk_fill,
+				 fbytes, fmt, args) + 1;
+		__ipipe_printk_fill += ret;
+	}
+
+	raw_spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+
+	if (oldcount == 0)
+		ipipe_raise_irq(__ipipe_printk_virq);
+
+	return ret;
+}
+
+void __ipipe_flush_printk (unsigned virq, void *cookie)
+{
+	char *p = __ipipe_printk_buf;
+	int len, lmax, out = 0;
+	unsigned long flags;
+
+	goto start;
+	do {
+	raw_spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+start:
+		lmax = __ipipe_printk_fill;
+		while (out < lmax) {
+			len = strlen(p) + 1;
+			printk("%s",p);
+			p += len;
+			out += len;
+		}
+		raw_spin_lock_irqsave(&__ipipe_printk_lock, flags);
+	}
+	while (__ipipe_printk_fill != lmax);
+
+	__ipipe_printk_fill = 0;
+
+	raw_spin_unlock_irqrestore(&__ipipe_printk_lock, flags);
+}
+
 /**
  * printk - print a kernel message
  * @fmt: format string
@@ -1829,6 +1889,44 @@ int vprintk_default(const char *fmt, va_list args)
  *
  * See the vsnprintf() documentation for format string extensions over C99.
  */
+
+asmlinkage __visible int printk(const char *fmt, ...)
+{
+	int sprintk = 1, cs = -1;
+	unsigned long flags;
+	va_list args;
+	int ret;
+
+	va_start(args, fmt);
+
+	flags = hard_local_irq_save();
+
+	if (__ipipe_printk_bypass || oops_in_progress)
+		cs = ipipe_disable_context_check();
+	else if (__ipipe_current_domain == ipipe_root_domain) {
+		if (ipipe_head_domain != ipipe_root_domain && 
+		    (raw_irqs_disabled_flags(flags) ||
+		     test_bit(IPIPE_STALL_FLAG, &__ipipe_head_status)))
+			sprintk = 0;
+	} else
+		sprintk = 0;
+
+	hard_local_irq_restore(flags);
+
+	if (sprintk) {
+		ret = vprintk_func(fmt, args);
+		if (cs != -1)
+			ipipe_restore_context_check(cs);
+	} else
+		ret = __ipipe_log_printk(fmt, args);
+
+	va_end(args);
+
+	return ret;
+}
+
+#else /* !CONFIG_IPIPE */
+
 asmlinkage __visible int printk(const char *fmt, ...)
 {
 	va_list args;
@@ -1840,6 +1938,9 @@ asmlinkage __visible int printk(const char *fmt, ...)
 
 	return r;
 }
+
+#endif /* CONFIG_IPIPE */
+
 EXPORT_SYMBOL(printk);
 
 #else /* CONFIG_PRINTK */
-- 
1.9.1

