From eb1b75b239674a7526003d499fac7dac66a8eada Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Wed, 4 Jul 2018 18:20:15 +0200
Subject: [PATCH 011/137] module: ipipe: enable try_module_get() from hard
 atomic context

We might have out-of-band code calling try_module_get() from the head
domain, or from a section covered by a hard spinlock where the root
domain must not reschedule. This requires the preemption management
calls in try_module_get() (and the converse module_put()) to be
converted to their hard variant.

REVISIT: using try_module_get() from such contexts is questionable,
client domains should be fixed.
---
 kernel/module.c | 8 ++++----
 1 file changed, 4 insertions(+), 4 deletions(-)

diff --git a/kernel/module.c b/kernel/module.c
index 811cbf2..80c88a2 100644
--- a/kernel/module.c
+++ b/kernel/module.c
@@ -1109,7 +1109,7 @@ bool try_module_get(struct module *module)
 	bool ret = true;
 
 	if (module) {
-		preempt_disable();
+		unsigned long flags = hard_preempt_disable();
 		/* Note: here, we can fail to get a reference */
 		if (likely(module_is_live(module) &&
 			   atomic_inc_not_zero(&module->refcnt) != 0))
@@ -1117,7 +1117,7 @@ bool try_module_get(struct module *module)
 		else
 			ret = false;
 
-		preempt_enable();
+		hard_preempt_enable(flags);
 	}
 	return ret;
 }
@@ -1128,11 +1128,11 @@ void module_put(struct module *module)
 	int ret;
 
 	if (module) {
-		preempt_disable();
+		unsigned long flags = hard_preempt_disable();
 		ret = atomic_dec_if_positive(&module->refcnt);
 		WARN_ON(ret < 0);	/* Failed to put refcount */
 		trace_module_put(module, _RET_IP_);
-		preempt_enable();
+		hard_preempt_enable(flags);
 	}
 }
 EXPORT_SYMBOL(module_put);
-- 
1.9.1

