From 279d21e51d05dbc5d2a74658e21a0eb60489099c Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Mon, 16 Jul 2018 10:17:54 +0200
Subject: [PATCH 022/137] KVM: ipipe: keep hypervisor state consistent across
 domain preemption

In order for the hypervisor to operate properly in presence of a
co-kernel, we need:

- the virtualization core to know when the hypervisor stalls due
  to a preemption by the co-kernel.

- to know when the VM enters and leaves guest mode.
---
 include/linux/ipipe.h      | 23 ++++++++++++++++++++++-
 include/linux/ipipe_base.h | 14 ++++++++++++++
 include/linux/kvm_host.h   |  3 +++
 kernel/ipipe/core.c        | 13 +++++++++++++
 4 files changed, 52 insertions(+), 1 deletion(-)

diff --git a/include/linux/ipipe.h b/include/linux/ipipe.h
index 45ca982..1aa9e8f 100644
--- a/include/linux/ipipe.h
+++ b/include/linux/ipipe.h
@@ -129,6 +129,28 @@ static inline void __ipipe_nmi_exit(void)
 		__clear_bit(IPIPE_STALL_FLAG, &__ipipe_root_status);
 }
 
+/* KVM-side calls, hw IRQs off. */
+static inline void __ipipe_enter_vm(struct ipipe_vm_notifier *vmf)
+{
+	struct ipipe_percpu_data *p;
+
+	p = raw_cpu_ptr(&ipipe_percpu);
+	p->vm_notifier = vmf;
+	barrier();
+}
+
+static inline void __ipipe_exit_vm(void)
+{
+	struct ipipe_percpu_data *p;
+
+	p = raw_cpu_ptr(&ipipe_percpu);
+	p->vm_notifier = NULL;
+	barrier();
+}
+
+/* Client-side call, hw IRQs off. */
+void __ipipe_notify_vm_preemption(void);
+
 static inline void __ipipe_sync_pipeline(struct ipipe_domain *top)
 {
 	if (__ipipe_current_domain != top) {
@@ -155,7 +177,6 @@ void ipipe_free_irq(struct ipipe_domain *ipd,
 
 void ipipe_raise_irq(unsigned int irq);
 
-
 void ipipe_set_hooks(struct ipipe_domain *ipd,
 		     int enables);
 
diff --git a/include/linux/ipipe_base.h b/include/linux/ipipe_base.h
index cf124f6..cbc3568 100644
--- a/include/linux/ipipe_base.h
+++ b/include/linux/ipipe_base.h
@@ -23,6 +23,8 @@
 #ifndef __LINUX_IPIPE_BASE_H
 #define __LINUX_IPIPE_BASE_H
 
+struct kvm_vcpu;
+struct ipipe_vm_notifier;
 struct irq_desc;
 
 #ifdef CONFIG_IPIPE
@@ -42,6 +44,10 @@ struct ipipe_trap_data {
 	struct pt_regs *regs;
 };
 
+struct ipipe_vm_notifier {
+	void (*handler)(struct ipipe_vm_notifier *nfy);
+};
+
 static inline int ipipe_virtual_irq_p(unsigned int irq)
 {
 	return irq >= IPIPE_VIRQ_BASE && irq < IPIPE_NR_IRQS;
@@ -167,6 +173,8 @@ struct ipipe_cpu_migration_data {
 
 void __ipipe_call_mayday(struct pt_regs *regs);
 
+void __ipipe_notify_vm_preemption(void);
+
 #define __ipipe_serial_debug(__fmt, __args...)	raw_printk(__fmt, ##__args)
 
 #else /* !CONFIG_IPIPE */
@@ -212,6 +220,12 @@ static inline void __ipipe_report_cleanup(struct mm_struct *mm) { }
 
 #define ipipe_handle_demuxed_irq(irq)		generic_handle_irq(irq)
 
+#define __ipipe_enter_vm(vmf)	do { } while (0)
+
+static inline void __ipipe_exit_vm(void) { }
+
+static inline void __ipipe_notify_vm_preemption(void) { }
+
 #define __ipipe_serial_debug(__fmt, __args...)	do { } while (0)
 
 #endif	/* !CONFIG_IPIPE */
diff --git a/include/linux/kvm_host.h b/include/linux/kvm_host.h
index b81d458..d47e0fc 100644
--- a/include/linux/kvm_host.h
+++ b/include/linux/kvm_host.h
@@ -219,6 +219,9 @@ struct kvm_vcpu {
 #ifdef CONFIG_PREEMPT_NOTIFIERS
 	struct preempt_notifier preempt_notifier;
 #endif
+#ifdef CONFIG_IPIPE
+	struct ipipe_vm_notifier ipipe_notifier;
+#endif
 	int cpu;
 	int vcpu_id;
 	int srcu_idx;
diff --git a/kernel/ipipe/core.c b/kernel/ipipe/core.c
index 8ee7336..28e8a6e 100644
--- a/kernel/ipipe/core.c
+++ b/kernel/ipipe/core.c
@@ -1256,6 +1256,19 @@ int __ipipe_switch_tail(void)
 	return !x;
 }
 
+void __ipipe_notify_vm_preemption(void)
+{
+	struct ipipe_vm_notifier *vmf;
+	struct ipipe_percpu_data *p;
+
+	ipipe_check_irqoff();
+	p = __ipipe_raw_cpu_ptr(&ipipe_percpu);
+	vmf = p->vm_notifier;
+	if (unlikely(vmf))
+		vmf->handler(vmf);
+}
+EXPORT_SYMBOL_GPL(__ipipe_notify_vm_preemption);
+
 static void dispatch_irq_head(unsigned int irq) /* hw interrupts off */
 {
 	struct ipipe_percpu_domain_data *p = ipipe_this_cpu_head_context(), *old;
-- 
1.9.1

