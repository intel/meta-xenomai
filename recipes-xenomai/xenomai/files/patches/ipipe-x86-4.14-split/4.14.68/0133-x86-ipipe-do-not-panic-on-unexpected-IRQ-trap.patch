From 8cf32855943f8e6023fe080634592b2db1a13723 Mon Sep 17 00:00:00 2001
From: Philippe Gerum <rpm@xenomai.org>
Date: Thu, 27 Sep 2018 09:09:52 +0200
Subject: [PATCH 133/137] x86: ipipe: do not panic on unexpected IRQ trap

Receiving unexpected IRQ traps may happen on some hardware, normally
the kernel would simply log a warning, acknowledge the erratic
interrupt in the local APIC, then be done with it.

Here the interrupt pipeline may be overreacting with a terminal panic
call. Mimick the non-pipelined behavior instead.
---
 arch/x86/kernel/ipipe.c | 11 +++++++++--
 1 file changed, 9 insertions(+), 2 deletions(-)

diff --git a/arch/x86/kernel/ipipe.c b/arch/x86/kernel/ipipe.c
index e9cd4d9..7c9b7cf 100644
--- a/arch/x86/kernel/ipipe.c
+++ b/arch/x86/kernel/ipipe.c
@@ -457,7 +457,14 @@ int __ipipe_handle_irq(struct pt_regs *regs)
 			irq = ipipe_apic_vector_irq(vector);
 		else {
 			desc = __this_cpu_read(vector_irq[vector]);
-			BUG_ON(IS_ERR_OR_NULL(desc));
+			if (IS_ERR_OR_NULL(desc)) {
+#ifdef CONFIG_X86_LOCAL_APIC
+				__ack_APIC_irq();
+#endif
+				pr_err("unexpected IRQ trap at vector %#x\n",
+				       vector);
+				goto out;
+			}
 			irq = irq_desc_get_irq(desc);
 		}
 	} else { /* Software-generated. */
@@ -493,7 +500,7 @@ int __ipipe_handle_irq(struct pt_regs *regs)
 		__ipipe_call_mayday(regs);
 
 	ipipe_trace_irqend(irq, regs);
-
+out:
 	if (!__ipipe_root_p ||
 	    test_bit(IPIPE_STALL_FLAG, &__ipipe_root_status))
 		return 0;
-- 
1.9.1

