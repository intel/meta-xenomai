From d4081ff38067368bbf7ce002dd67a91c63e29c26 Mon Sep 17 00:00:00 2001
From: florent pirou <florent.pirou@intel.com>
Date: Thu, 30 Nov 2017 18:42:47 +0100
Subject: [PATCH 3/4] Sometimes it is beneficial to be able to park the gpu
 into a specific frequency to observe the effect on the spoolup time and
 latencies.

Note that we don't save the value during suspend/resume.
We could but we don't want to clutter the mechanics
with another softcap variable and accept this limitation.

Cc: Chris Wilson <chris@chris-wilson.co.uk>
Cc: Joonas Lahtinen <joonas.lahtinen@linux.intel.com>

Signed-off-by: Mika Kuoppala <mika.kuoppala@intel.com>
Signed-off-by: florent pirou <florent.pirou@intel.com>
---
 drivers/gpu/drm/i915/i915_debugfs.c | 57 +++++++++++++++++++++++++++++++++++++
 1 file changed, 57 insertions(+)

diff --git a/drivers/gpu/drm/i915/i915_debugfs.c b/drivers/gpu/drm/i915/i915_debugfs.c
index fd52e6f..17c0744 100644
--- a/drivers/gpu/drm/i915/i915_debugfs.c
+++ b/drivers/gpu/drm/i915/i915_debugfs.c
@@ -4535,6 +4535,62 @@ static ssize_t cur_wm_latency_write(struct file *file, const char __user *ubuf,
 			"%llu\n");
 
 static int
+i915_idle_freq_get(void *data, u64 *val)
+{
+
+	struct drm_i915_private *dev_priv = data;
+
+	if (INTEL_GEN(dev_priv) < 6)
+		return -ENODEV;
+
+	*val = intel_gpu_freq(dev_priv, dev_priv->rps.idle_freq);
+	return 0;
+}
+
+static int
+i915_idle_freq_set(void *data, u64 val)
+{
+	struct drm_i915_private *dev_priv = data;
+	u32 hw_max, hw_min;
+	int ret;
+
+if (INTEL_GEN(dev_priv) < 6)
+	return -ENODEV;
+
+	DRM_DEBUG_DRIVER("Manually setting idle freq to %llu\n", val);
+
+	ret = mutex_lock_interruptible(&dev_priv->pcu_lock);
+
+	if (ret)
+		return ret;
+
+	/*
+	* Turbo will still be enabled, but won't go below the set value.
+	*/
+	val = intel_freq_opcode(dev_priv, val);
+	hw_max = dev_priv->rps.max_freq;
+	hw_min = dev_priv->rps.min_freq;
+
+	if (val < hw_min || val > hw_max) {
+		mutex_unlock(&dev_priv->pcu_lock);
+		return -EINVAL;
+	}
+
+	dev_priv->rps.idle_freq = val;
+
+	if (intel_set_rps(dev_priv, val))
+		DRM_DEBUG_DRIVER("failed to update RPS to new idle\n");
+
+	mutex_unlock(&dev_priv->pcu_lock);
+
+	return 0;
+}
+
+DEFINE_SIMPLE_ATTRIBUTE(i915_idle_freq_fops,
+		i915_idle_freq_get, i915_idle_freq_set,
+		"%llu\n");
+
+static int
 i915_cache_sharing_get(void *data, u64 *val)
 {
 	struct drm_i915_private *dev_priv = data;
@@ -4935,6 +4991,7 @@ static int i915_hpd_storm_ctl_open(struct inode *inode, struct file *file)
 	{"i915_wedged", &i915_wedged_fops},
 	{"i915_max_freq", &i915_max_freq_fops},
 	{"i915_min_freq", &i915_min_freq_fops},
+	{"i915_idle_freq", &i915_idle_freq_fops},
 	{"i915_cache_sharing", &i915_cache_sharing_fops},
 	{"i915_ring_missed_irq", &i915_ring_missed_irq_fops},
 	{"i915_ring_test_irq", &i915_ring_test_irq_fops},
-- 
1.9.1

